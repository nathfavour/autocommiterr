#!/usr/bin/env bun

import { Command } from 'commander';
import * as readline from 'readline';
import changesSummarizer from './src/changesSummarizer';
import gitmoji from './src/gitmoji';
import modelManager from './src/modelManager';
import apiClient from './src/apiClient';
import gitUtils from './src/gitUtils';

const program = new Command();

program
  .name('autocommiterr')
  .description('Auto-commit messages using AI (Bun CLI version)')
  .version('1.0.0');

// Helper to prompt user input
function prompt(question: string): Promise<string> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      rl.close();
      resolve(answer);
    });
  });
}

// Main autocommit command
program
  .command('commit')
  .description('Generate and commit changes automatically')
  .option('-m, --message <msg>', 'Use custom commit message instead of generating')
  .option('--no-gitmoji', 'Disable gitmoji for this commit')
  .option('--push', 'Push after committing')
  .action(async (options) => {
    try {
      const cwd = gitUtils.getRepoRoot();
      console.log('üìç Repository:', cwd);

      // 1) Ensure .gitignore safety
      console.log('üîí Ensuring .gitignore safety...');
      await gitUtils.ensureGitignoreSafety(cwd);

      // 2) Stage all changes
      console.log('üì¶ Staging changes (git add .)...');
      gitUtils.stageAllChanges(cwd);

      // 3) Check for staged files
      console.log('üîç Checking staged changes...');
      const staged = gitUtils.getStagedFiles(cwd);
      if (!staged) {
        console.log('‚ÑπÔ∏è  No changes to commit ‚Äî Autocommit skipped.');
        return;
      }

      let message = options.message || '';

      // 4) Generate message if not provided
      if (!message) {
        console.log('ü§ñ Generating commit message...');
        
        const apiKey = await modelManager.getApiKey();
        if (!apiKey) {
          console.log('‚ö†Ô∏è  No API key found. Using default message.');
          message = 'chore: automated commit generated by Autocommiter';
        } else {
          try {
            const selectedModel = await modelManager.getSelectedModelId();
            const fileChanges = await changesSummarizer.buildFileChanges(cwd);
            const fileNames = fileChanges.map(f => f.file).slice(0, 50).join('\n');
            const compressedJson = changesSummarizer.compressToJson(fileChanges, 400);
            const userPrompt = `reply only with a very concise but informative commit message, and nothing else:\n\nFiles:\n${fileNames}\n\nSummaryJSON:${compressedJson}`;
            
            try {
              const aiResult = await apiClient.callInferenceApi(apiKey, userPrompt, selectedModel);
              if (aiResult && aiResult.trim().length > 0) {
                message = aiResult.trim();
                console.log(`‚úì Used ${selectedModel} to generate the message.`);
              }
            } catch (apiErr) {
              console.error('‚ö†Ô∏è  API-based generation failed:', (apiErr as Error)?.message);
              message = 'chore: automated commit generated by Autocommiter';
            }
          } catch (e) {
            console.error('‚ö†Ô∏è  Failed to generate message:', (e as Error)?.message);
            message = 'chore: automated commit generated by Autocommiter';
          }
        }
      }

      // 5) Apply gitmoji if enabled and not disabled
      if (options.gitmoji !== false) {
        const gitmojiEnabled = await modelManager.getGitmojiEnabled();
        if (gitmojiEnabled) {
          message = gitmoji.getGitmojifiedMessage(message);
        }
      }

      console.log('\nüìù Commit message:');
      console.log(`   "${message}"\n`);

      // 6) Commit changes
      console.log('üíæ Committing staged changes...');
      await gitUtils.commit(cwd, message);
      console.log('‚úì Changes committed locally.');

      // 7) Push if requested
      if (options.push) {
        console.log('üöÄ Pushing to remote...');
        gitUtils.push(cwd);
        console.log('‚úì Changes pushed to remote.');
      }
    } catch (err: any) {
      console.error('‚ùå Error:', err?.message || String(err));
      process.exit(1);
    }
  });

// API key management
program
  .command('config:apikey')
  .description('Set your GitHub Models API key')
  .action(async () => {
    try {
      const apiKey = await prompt('Enter your GitHub Models API key: ');
      if (!apiKey.trim()) {
        console.log('‚ùå API key cannot be empty.');
        return;
      }
      await modelManager.setApiKey(apiKey.trim());
      console.log('‚úì API key saved successfully.');
    } catch (err: any) {
      console.error('‚ùå Error:', err?.message || String(err));
      process.exit(1);
    }
  });

// Model selection
program
  .command('config:model')
  .description('Select your preferred AI model')
  .action(async () => {
    try {
      const apiKey = await modelManager.getApiKey();
      if (!apiKey) {
        console.log('‚ùå No API key found. Run "autocommiterr config:apikey" first.');
        return;
      }

      console.log('üì• Fetching available models...');
      const models = await modelManager.fetchAvailableModels(apiKey);

      console.log('\nAvailable models:');
      models.forEach((m, i) => {
        console.log(`${i + 1}. ${m.friendly_name || m.name}`);
        console.log(`   ${m.summary || 'No description'}`);
      });

      const selected = await prompt('\nSelect model (number): ');
      const index = parseInt(selected) - 1;

      if (index < 0 || index >= models.length) {
        console.log('‚ùå Invalid selection.');
        return;
      }

      const selectedModel = models[index];
      await modelManager.setSelectedModelId(selectedModel.id);
      await modelManager.updateCachedModels(models);
      console.log(`‚úì Model "${selectedModel.friendly_name || selectedModel.name}" selected.`);
    } catch (err: any) {
      console.error('‚ùå Error:', err?.message || String(err));
      process.exit(1);
    }
  });

// Refresh models from API
program
  .command('config:refresh-models')
  .description('Fetch and cache available models from GitHub Models API')
  .action(async () => {
    try {
      const apiKey = await modelManager.getApiKey();
      if (!apiKey) {
        console.log('‚ùå No API key found. Run "autocommiterr config:apikey" first.');
        return;
      }

      console.log('üì• Fetching models from GitHub Models API...');
      const models = await modelManager.fetchAvailableModels(apiKey);

      if (models.length > 0) {
        await modelManager.updateCachedModels(models);
        console.log(`‚úì Successfully fetched and cached ${models.length} models.`);
      } else {
        console.log('‚ö†Ô∏è  No chat-completion models found.');
      }
    } catch (err: any) {
      console.error('‚ùå Error:', err?.message || String(err));
      process.exit(1);
    }
  });

// Gitmoji settings
program
  .command('config:gitmoji <enable>')
  .description('Enable or disable gitmoji prefixes (true/false)')
  .action(async (enable: string) => {
    try {
      const enabled = enable.toLowerCase() === 'true' || enable === '1' || enable === 'yes';
      await modelManager.setGitmojiEnabled(enabled);
      console.log(`‚úì Gitmoji ${enabled ? 'enabled' : 'disabled'}.`);
    } catch (err: any) {
      console.error('‚ùå Error:', err?.message || String(err));
      process.exit(1);
    }
  });

// Show current config
program
  .command('config:show')
  .description('Show current configuration')
  .action(async () => {
    try {
      const apiKey = await modelManager.getApiKey();
      const selectedModel = await modelManager.getSelectedModelId();
      const gitmojiEnabled = await modelManager.getGitmojiEnabled();
      const cachedModels = await modelManager.getCachedModels();

      console.log('\nüìã Current Configuration:\n');
      console.log(`API Key: ${apiKey ? '‚úì Set' : '‚úó Not set'}`);
      console.log(`Selected Model: ${selectedModel}`);
      console.log(`Gitmoji Enabled: ${gitmojiEnabled ? 'Yes' : 'No'}`);
      console.log(`Cached Models: ${cachedModels.length}`);
      console.log();
    } catch (err: any) {
      console.error('‚ùå Error:', err?.message || String(err));
      process.exit(1);
    }
  });

// Parse and handle
try {
  program.parse(process.argv);
} catch (err: any) {
  console.error('‚ùå Error:', err?.message || String(err));
  process.exit(1);
}

// Show help if no arguments
if (!process.argv.slice(2).length) {
  program.outputHelp();
}