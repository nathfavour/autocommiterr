#!/usr/bin/env node

import { Command } from 'commander';
import * as readline from 'readline';
import changesSummarizer from './src/changesSummarizer.js';
import gitmoji from './src/gitmoji.js';
import modelManager from './src/modelManager.js';
import apiClient from './src/apiClient.js';
import gitUtils from './src/gitUtils.js';

const program = new Command();

program
  .name('autocommiterr')
  .description('Auto-commit messages using AI')
  .version('1.0.0');

// Helper to prompt user input
function prompt(question: string): Promise<string> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      rl.close();
      resolve(answer);
    });
  });
}

/**
 * Main commit logic
 */
async function performCommit(options: any = {}): Promise<void> {
  try {
    // Use quiet setting from config if not overridden
    let quiet = options.quiet;
    if (quiet === undefined) {
      quiet = await modelManager.getQuietMode();
    }

    const cwd = gitUtils.getRepoRoot();
    if (!quiet) console.log('üìç Repository:', cwd);

    // 1) Ensure .gitignore safety
    if (!quiet) console.log('üîí Ensuring .gitignore safety...');
    await gitUtils.ensureGitignoreSafety(cwd);
    if (!quiet) console.log('‚úì .gitignore is safe.');

    // 2) Stage all changes
    if (!quiet) console.log('üì¶ Staging changes (git add .)...');
    gitUtils.stageAllChanges(cwd);

    // 3) Check for staged files
    if (!quiet) console.log('üîç Checking staged changes...');
    const staged = gitUtils.getStagedFiles(cwd);
    if (!staged) {
      console.log('‚ÑπÔ∏è  No changes to commit ‚Äî Autocommit skipped.');
      return;
    }

    let message = options.message || '';

    // 4) Generate message if not provided
    if (!message) {
      if (!quiet) console.log('ü§ñ Generating commit message...');
      
      const apiKey = await modelManager.getApiKey();
      if (!apiKey) {
        if (!quiet) console.log('‚ö†Ô∏è  No API key found. Using default message.');
        message = 'chore: automated commit generated by Autocommiter';
      } else {
        try {
          const selectedModel = await modelManager.getSelectedModelId();
          const fileChanges = await changesSummarizer.buildFileChanges(cwd);
          const fileNames = fileChanges.map(f => f.file).slice(0, 50).join('\n');
          const compressedJson = changesSummarizer.compressToJson(fileChanges, 400);
          const userPrompt = `reply only with a very concise but informative commit message, and nothing else:\n\nFiles:\n${fileNames}\n\nSummaryJSON:${compressedJson}`;
          
          try {
            const aiResult = await apiClient.callInferenceApi(apiKey, userPrompt, selectedModel);
            if (aiResult && aiResult.trim().length > 0) {
              message = aiResult.trim();
              if (!quiet) console.log(`‚úì Used ${selectedModel} to generate the message.`);
            }
          } catch (apiErr) {
            if (!quiet) console.error('‚ö†Ô∏è  API-based generation failed:', (apiErr as Error)?.message);
            message = 'chore: automated commit generated by Autocommiter';
          }
        } catch (e) {
          if (!quiet) console.error('‚ö†Ô∏è  Failed to generate message:', (e as Error)?.message);
          message = 'chore: automated commit generated by Autocommiter';
        }
      }
    }

    // 5) Apply gitmoji if enabled and not disabled
    if (options.gitmoji !== false) {
      const gitmojiEnabled = await modelManager.getGitmojiEnabled();
      if (gitmojiEnabled) {
        message = gitmoji.getGitmojifiedMessage(message);
      }
    }

    if (!quiet) {
      console.log('\nüìù Commit message:');
      console.log(`   "${message}"\n`);
    }

    // 6) Commit changes
    if (!quiet) console.log('üíæ Committing staged changes...');
    await gitUtils.commit(cwd, message);
    console.log('‚úì Changes committed successfully.');

    // 7) Push if requested
    if (options.push) {
      if (!quiet) console.log('üöÄ Pushing to remote...');
      gitUtils.push(cwd);
      console.log('‚úì Changes pushed to remote.');
    }
  } catch (err: any) {
    console.error('‚ùå Error:', err?.message || String(err));
    process.exit(1);
  }
}

// Main autocommit command
program
  .command('commit')
  .description('Generate and commit changes automatically')
  .option('-m, --message <msg>', 'Use custom commit message instead of generating')
  .option('--no-gitmoji', 'Disable gitmoji for this commit')
  .option('--push', 'Push after committing')
  .option('--quiet', 'Suppress output (useful for scripts)')
  .action((options) => performCommit(options));

// Make 'commit' the default when no arguments provided
program.option('--push', 'Push after committing')
  .option('--message <msg>', 'Custom commit message')
  .option('--no-gitmoji', 'Disable gitmoji for this commit')
  .option('--quiet', 'Suppress output')
  .action((options) => {
    // Only run if no recognized command was used
    if (!process.argv.slice(2).some(arg => !arg.startsWith('-'))) {
      performCommit(options);
    }
  });


// API key management
program
  .command('config:apikey')
  .description('Set your GitHub Models API key')
  .action(async () => {
    try {
      const apiKey = await prompt('Enter your GitHub Models API key: ');
      if (!apiKey.trim()) {
        console.log('‚ùå API key cannot be empty.');
        return;
      }
      await modelManager.setApiKey(apiKey.trim());
      console.log('‚úì API key saved successfully.');
    } catch (err: any) {
      console.error('‚ùå Error:', err?.message || String(err));
      process.exit(1);
    }
  });

// Model selection
program
  .command('config:model')
  .description('Select your preferred AI model')
  .action(async () => {
    try {
      const apiKey = await modelManager.getApiKey();
      if (!apiKey) {
        console.log('‚ùå No API key found. Run "autocommiterr config:apikey" first.');
        return;
      }

      console.log('üì• Fetching available models...');
      const models = await modelManager.fetchAvailableModels(apiKey);

      console.log('\nAvailable models:');
      models.forEach((m, i) => {
        console.log(`${i + 1}. ${m.friendly_name || m.name}`);
        console.log(`   ${m.summary || 'No description'}`);
      });

      const selected = await prompt('\nSelect model (number): ');
      const index = parseInt(selected) - 1;

      if (index < 0 || index >= models.length) {
        console.log('‚ùå Invalid selection.');
        return;
      }

      const selectedModel = models[index];
      await modelManager.setSelectedModelId(selectedModel.id);
      await modelManager.updateCachedModels(models);
      console.log(`‚úì Model "${selectedModel.friendly_name || selectedModel.name}" selected.`);
    } catch (err: any) {
      console.error('‚ùå Error:', err?.message || String(err));
      process.exit(1);
    }
  });

// Refresh models from API
program
  .command('config:refresh-models')
  .description('Fetch and cache available models from GitHub Models API')
  .action(async () => {
    try {
      const apiKey = await modelManager.getApiKey();
      if (!apiKey) {
        console.log('‚ùå No API key found. Run "autocommiterr config:apikey" first.');
        return;
      }

      console.log('üì• Fetching models from GitHub Models API...');
      const models = await modelManager.fetchAvailableModels(apiKey);

      if (models.length > 0) {
        await modelManager.updateCachedModels(models);
        console.log(`‚úì Successfully fetched and cached ${models.length} models.`);
      } else {
        console.log('‚ö†Ô∏è  No chat-completion models found.');
      }
    } catch (err: any) {
      console.error('‚ùå Error:', err?.message || String(err));
      process.exit(1);
    }
  });

// Gitmoji settings
program
  .command('config:gitmoji <enable>')
  .description('Enable or disable gitmoji prefixes (true/false/enable/disable)')
  .action(async (enable: string) => {
    try {
      const val = enable.toLowerCase();
      const enabled = val === 'true' || val === '1' || val === 'yes' || val === 'enable';
      await modelManager.setGitmojiEnabled(enabled);
      console.log(`‚úì Gitmoji ${enabled ? 'enabled' : 'disabled'}.`);
    } catch (err: any) {
      console.error('‚ùå Error:', err?.message || String(err));
      process.exit(1);
    }
  });

// Show current config
program
  .command('config:show')
  .description('Show current configuration')
  .action(async () => {
    try {
      const apiKey = await modelManager.getApiKey();
      const selectedModel = await modelManager.getSelectedModelId();
      const gitmojiEnabled = await modelManager.getGitmojiEnabled();
      const cachedModels = await modelManager.getCachedModels();

      console.log('\nüìã Current Configuration:\n');
      console.log(`API Key: ${apiKey ? '‚úì Set' : '‚úó Not set'}`);
      console.log(`Selected Model: ${selectedModel}`);
      console.log(`Gitmoji Enabled: ${gitmojiEnabled ? 'Yes' : 'No'}`);
      console.log(`Cached Models: ${cachedModels.length}`);
      const quietMode = await modelManager.getQuietMode();
      console.log(`Quiet Mode: ${quietMode ? 'Yes' : 'No'}`);
      console.log();
    } catch (err: any) {
      console.error('‚ùå Error:', err?.message || String(err));
      process.exit(1);
    }
  });

// Quiet mode settings
program
  .command('config:quiet <enable>')
  .description('Enable or disable quiet mode (true/false/enable/disable)')
  .action(async (enable: string) => {
    try {
      const val = enable.toLowerCase();
      const enabled = val === 'true' || val === '1' || val === 'yes' || val === 'enable';
      await modelManager.setQuietMode(enabled);
      console.log(`‚úì Quiet mode ${enabled ? 'enabled' : 'disabled'}.`);
    } catch (err: any) {
      console.error('‚ùå Error:', err?.message || String(err));
      process.exit(1);
    }
  });

// Parse and handle
let commandWasRun = false;

// Wrap the original parse to detect if a command ran
const originalParse = program.parse.bind(program);
program.parse = function(argv: string[]) {
  const args = argv.slice(2);
  
  // Check if it's a recognized command
  const recognizedCommands = ['commit', 'config:apikey', 'config:model', 'config:refresh-models', 'config:gitmoji', 'config:quiet', 'config:show'];
  const isCommand = args.length > 0 && recognizedCommands.includes(args[0]);
  
  if (isCommand) {
    commandWasRun = true;
    return originalParse(argv);
  }
  
  // Not a recognized command - run default commit instead
  if (!args.length || args.every(arg => arg.startsWith('-'))) {
    const options: any = {};
    if (args.includes('--push')) options.push = true;
    if (args.includes('--quiet')) options.quiet = true;
    if (args.includes('--no-gitmoji')) options.gitmoji = false;
    
    // Extract message if provided
    for (let i = 0; i < args.length; i++) {
      if ((args[i] === '-m' || args[i] === '--message') && i + 1 < args.length) {
        options.message = args[i + 1];
      }
    }
    
    performCommit(options);
    return program;
  }
  
  // Otherwise parse normally
  return originalParse(argv);
};

try {
  program.parse(process.argv);
} catch (err: any) {
  console.error('‚ùå Error:', err?.message || String(err));
  process.exit(1);
}
